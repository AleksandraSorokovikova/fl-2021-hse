%{
#include <iostream>
#include <set>
#include <vector>
#include <map>
#include <string>
#include <cstdlib>

int yylex();

int yyerror(const char *p) { std::cerr << "Error!" << std::endl; }

struct Parser;

struct Automate {

private:

    std::set<std::string> states;
    std::set<std::string> terminals;
    std::set<char> alphabet;
    std::set<std::pair<char, std::pair<std::string, std::string> > > transitions;
    std::string start;
    friend Parser;

public:

    void define_start(std::string start_) {
        start = start_;
    }

    void add_state(std::string state_) {
        states.insert(state_);
    }

    void add_terminal(std::string terminal_) {
        terminals.insert(terminal_);
    }

    void add_letter(char letter_) {
        alphabet.insert(letter_);
    }

    void add_transition(std::string state_1, std::string state_2, char letter_) {
        transitions.insert(std::make_pair(letter_, std::make_pair(state_1, state_2))); 
    }

};


struct state_current {

private:
    bool finish;

public:

    state_current(bool finish_) {
        finish = finish_;
    }

    std::map<char, state_current*> transitions;

    void change_state(char symbol) {
        *this = *transitions[symbol];
    }

    void set_terminal() {
        finish = true;
    }

    bool finish_state() const{
        return finish;
    }

};

Automate automate;

struct Parser {

    Parser() {

        for(auto state : automate.states){
            states_[state] = new state_current(false);
        }

        for(auto transition: automate.transitions){
            states_[transition.second.first]->transitions[transition.first] = states_[transition.second.second];
        }

        for(auto state : automate.terminals){
            states_[state]->set_terminal();
        }

    }

    bool parse(std::string string_to_parse) {
        for(auto symbol : string_to_parse){
            states_[automate.start]->change_state(symbol);
        }
        return states_[automate.start]->finish_state();
    }

private:
    std::map<std::string, state_current*> states_;
};


%}

%union {
  char* val;
  char sym;
};

%token <val> STATES 
%token <val> START 
%token <val> TERMINALS 
%token <val> ALPHABET 
%token <val> TRANSITIONS 
%token <val> STATE_NAME
%token <sym> SEMICOLON 
%token <sym> LETTER

%%
start: States Start Terminals Alphabet Transitions {}

States: STATES Enum_state {}

Enum_state: Enum_state STATE_NAME { 
    automate.add_state($2); 
}

| STATE_NAME {
    automate.add_state($1);
}

Start: START STATE_NAME {
    automate.define_start($2);
}

Terminals: TERMINALS Enum_terminals {}

Enum_terminals: Enum_terminals STATE_NAME {
    automate.add_terminal($2);
}

| STATE_NAME {
    automate.add_terminal($1); 
}

Alphabet: ALPHABET Enum_letters {}

Enum_letters: Enum_letters LETTER {
    automate.add_letter($2); 
}
| LETTER {
    automate.add_letter($1);
}

Transitions: TRANSITIONS Enum_transition {}

Enum_transition: Enum_transition transition {}
| transition {}

transition: STATE_NAME SEMICOLON STATE_NAME SEMICOLON LETTER { 
  automate.add_transition($1, $3, $5); 
}

%%

int main(int argc, char* argv[]) {
    

    freopen(argv[1], "r", stdin);

    yyparse();

    fclose(stdin);

    Parser parser;

    freopen(argv[2], "r", stdin);
    std::string string_to_parse;
    std::cin >> string_to_parse;
    fclose(stdin);

    bool parsing_result = parser.parse(string_to_parse);

    if (parsing_result) {
        std::cout << "Belongs to the language\n";
        return 0;
    }

    std::cout << "NÐ¾ matching\n";
    
    return 0;

}